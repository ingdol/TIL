# 팩토리 메서드 Factory Method

[팩토리 메서드 패턴](https://refactoring.guru/ko/design-patterns/factory-method)

# 의도

- 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴

![Untitled](%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%20Factory%20Method%2002c3258a19904f5284dee336d4cdfeb9/Untitled.png)

# 문제

- 물류 관리 앱을 개발하고 있다고 가정
- 앱의 첫 번째 버전은 트럭 운송만 처리할 수 있음
  - 대부분의 코드가 Truck(트럭) 클래스에 있음
- 해상 물류 기능을 추가해야 한다면
  - 현재 대부분의 코드는 Truck 클래스에 결합되어 있어
  - Ship(선박) 클래스를 추가하려면 전체 코드 베이스를 변경해야 함
- 결과적으로, 운송 수단에 따라 많은 조건문의 매우 복잡한 코드가 작성될 것임

# 해결책

- 팩토리 메서드 패턴은(`new` 연산자를 사용한) 객체 생성 직접 호출들을 특별한 팩토리 메서드에 대한 호출들로 대체하라고 제안
  - 객체들은 `new` 연산자를 통해 생성되지만 팩토리 메서드 내에서 호출되고 있음
  - 팩터리 메서드에서 반환된 객체는 종종 제품이라고도 불림

![자식 클래스들은 팩토리 메서드가 반환하는 객체들의 클래스를 변경할 수 있음](%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%20Factory%20Method%2002c3258a19904f5284dee336d4cdfeb9/Untitled%201.png)

자식 클래스들은 팩토리 메서드가 반환하는 객체들의 클래스를 변경할 수 있음

- 자식 클래스에서 팩토리 메서드를 오버라이딩하고 그 메서드에 의해 생성되는 제품들의 클래스를 변경할 수 있게 됨
- 자식 클래스들은 다른 유형의 제품들을 해당 제품들이 공통 기초 클래스 또는 공통 인터페이스가 있는 경우에만 반환할 수 있음

![모든 제품들은 같은 인터페이스를 따라야 함](%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%20Factory%20Method%2002c3258a19904f5284dee336d4cdfeb9/Untitled%202.png)

모든 제품들은 같은 인터페이스를 따라야 함

- `Truck`과 `Ship` 클래스들은 모두 `Transport` 인터페이스를 구현해야 하며, 이 인터페이스는 `deliver` (배달)라는 메서드를 선언함
  - 그러나 각 클래스는 이 메서드를 다르게 구현함
  - `RoadLogistics`(도로 물류) 클래스에 포함된 팩토리 메서드는 `Truck` 객체들을 반환
  - `SeaLogistics` (해운 물류) → `Ship` 반환

팩토리 메서드를 이용하여 각 해당하는 메소드의 객체 반환

![모든 제품 클래스들이 공통 인터페이스를 구현하는 한, 제품 클래스들의 객체들을 손상하지 않고 클라이언트 코드를 통과시킬 수 있음](%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%20Factory%20Method%2002c3258a19904f5284dee336d4cdfeb9/Untitled%203.png)

모든 제품 클래스들이 공통 인터페이스를 구현하는 한, 제품 클래스들의 객체들을 손상하지 않고 클라이언트 코드를 통과시킬 수 있음

- 팩토리 메서드를 사용하는 코드를 종종 클라이언트 코드라고 부름
  - 클라이언트 코드 : 다양한 자식 클래스들에서 실제로 반환되는 여러 제품 간의 차이를 알지 못함
  - 클라이언트 코드는 모든 제품을 추상 `Transport` (운송체계)로 간주함
  - 클라이언트는 모든 `Transport` 객체들이 `deliver`(배달) 메서드를 가져야 한다는 사실을 알고 있지만, 이 메서드가 정확히 어떻게 작동하는지는 클라이언트에게 중요하지 않음

# 구조

![Untitled](%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%20Factory%20Method%2002c3258a19904f5284dee336d4cdfeb9/Untitled%204.png)

1. 제품
   - 인터페이스를 선언함
   - 인터페이스는 생성자와 자식 클래스들이 생성할 수 있는 모든 객체의 공통임
2. 구상 제품
   - 제품 인터페이스의 다양한 구현들
3. 크리에이터(Creator) 클래스
   - 새로운 제품 객체들을 반환하는 팩토리 메서드를 선언함
   - 중요한 점 : 이 팩토리 메서드의 반환 유형이 제품 인터페이스와 일치해야 함
   - 팩토리 메서드를 `abstract`(추상)로 선언하여 모든 자식 클래스들이 각각 이 메서드의 자체 버전들을 구현하도록 강제할 수 있음
   - 대안적으로 기초 팩토리 메서드가 디폴트 제품 유형을 반환하도록 만들 수 있음
   - 일반적으로 크리에이터 클래스에는 이미 제품과 관련된 핵심 비즈니스 로직이 있으며, 팩토리 메서드는 이 로직을 구상 제품 클래스들로부터 분리하는 데 도움을 줌
     - ex) 대규모 소프트웨어 개발사에 비유 : 프로그래머들을 위한 교육 부서가 있을 수 있으나, 회사의 주 임무는 프래그래머를 교육하는 것이 아니라 코드를 작성하는 것
   1. 구상 크리에이터
      - 기초 팩토리 메서드를 오버라이드(재정의)하여 다른 유형의 제품을 반환하게 함
      - 팩토리 메서드는 항상 새로운 인스턴스들을 생성해야 할 필요가 없음
      - 팩토리 메서드는 기존 객체들을 캐시, 객체 풀 또는 다른 소스로부터 반환할 수 있음
