# 빌더 Builder

[빌더 패턴](https://refactoring.guru/ko/design-patterns/builder)

## 의도

- 빌더 : 복잡한 객체들을 단계별로 생성할 수 있도록 하는 생성 디자인 패턴
- 이 패턴을 사용하면 같은 제작 코드를 사용하여 객체의 다양한 유형들과 표현을 제작할 수 있음

![Untitled](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled.png)

## 문제

- 많은 필드와 중첩된 객체들을 힘들게 단계별로 초기화해야 하는 복잡한 객체를 가정
  - 이러한 초기화 코드는 일반적으로 많은 매개변수가 있는 생성자 내부에 묻혀 있음
  - 최악의 상황에는 클라이언트 코드 전체에 흩어져 있을 수 있음

![객체의 가능한 모든 설정에 자식 클래스를 만들어 프로그램을 매우 복잡하게 만들 수 있음](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled%201.png)

객체의 가능한 모든 설정에 자식 클래스를 만들어 프로그램을 매우 복잡하게 만들 수 있음

- 예를 들어 `House` (집) 객체를 만드는 방법을 생각해보면
  - 간단한 집을 만든 후 뒤뜰과 기타 물품(난방 시스템 등)이 더 추가로 필요하다면
  - 이를 해결하기 위해 기초 `House` 클래스를 확장하고 매개변수의 모든 조합을 포함하는 자식 클래스들의 집합을 만드는 것 → 그러나 상단한 수의 자식 클래스 생성
  - 새로운 매개변수(예: 현관 스타일)을 추가할 때마다 이 계층구조는 훨씬 더 복잡해짐
- 자식 클래스들을 늘리지 않는 다른 접근 방식
  - 기초 `House` 클래스에 `House` 객체를 제어하는 모든 가능한 매개변수를 포함한 거대한 생성자를 만드는 것
  - 이 접근 방식은 실제로 자식 클래스들의 필요성을 제거하나, 다른 문제를 만들어 냄
    ![매개변수가 많은 생성자의 단점은 모든 매개변수가 항상 필요한 것은 아님](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled%202.png)
    매개변수가 많은 생성자의 단점은 모든 매개변수가 항상 필요한 것은 아님
- 보통 대부분의 매개변수가 사용되지 않아 생성자 호출들의 코드가 매우 복잡해짐
  - 예를 들어, 집에 수영장은 매개변수로 사용되지 않을 수 도 있음

## 해결책

- 빌더 패턴은 자신의 클래스에서 객체 생성 코드를 추출하여 builders(건축업자들)라는 별도의 객체들로 이동하도록 제안

![빌더 패턴은 복잡한 객체들을 단계별로 생성할 수 있도록 함. 빌더는 제품이 생성되는 동안 다른 객체들이 제품에 접근(access)하는 것을 허용하지 않음](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled%203.png)

빌더 패턴은 복잡한 객체들을 단계별로 생성할 수 있도록 함. 빌더는 제품이 생성되는 동안 다른 객체들이 제품에 접근(access)하는 것을 허용하지 않음

- 이 패턴은 객체 생성을 일련의 단계들(`buildWalls` , `buildDoor` 등)으리 정리
- 객체를 생성하고 싶으면 위 단계들을 builder(빌더) 객체에 실행하면 됨
- 중요한 점 : 모든 단계를 호출할 필요가 없다는 것, 객체의 특정 설정을 제작하는 데 필요한 단계들만 호출하면 됨
- 일부 건축 단계들은 제품의 다양한 표현을 건축해야 하는 경우 다른 구현들이 필요할 수 있음
  - 예를 들어, 오두막의 벽은 나무로 지을 수 있지만 성벽은 돌로 지어야 함
  - 이런 경우 같은 건축 단계들의 집합을 다른 방식으로 구현하는 여러 다른 빌더 클래스를 생성할 수 있음
  - 그런 다음 건축 프로세스(즉, 건축 단계에 대한 순서화된 호출들의 집합)내에서 이러한 빌더들을 사용하여 다양한 종류의 객체를 생성할 수 있음

![다양한 빌더들은 다양한 방식으로 같은 작업을 실행함](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled%204.png)

다양한 빌더들은 다양한 방식으로 같은 작업을 실행함

- 예를 들어, 나무와 유리로 건축하는 건축가 / 돌과 철로 건축하는 건축가 / 금과 다이아몬드로 건축하는 건축가가 있을 경우
  - 이 세 건축가에 대해 같은 단계들의 집합을 호출하면 일반 주택 / 작은 성 / 궁전을 얻을 수 있음
  - 그러나 위에 예시된 경우는 건축 단계들을 호출하는 클라이언트 코드가 공통 인터페이스를 사용하여 빌더들과 상호 작용할 수 있는 경우에만 작동

### 디렉터(관리자)

- 제품을 생성하는 데 사용하는 빌더 관계들에 대한 일련의 호출을 디렉터(관리자)라는 별도의 클래스로 추출할 수 있음
- 디렉터 클래스는 제작 단계들을 실행하는 순서를 정의하는 반면 빌더는 이러한 단계들에 대한 구현을 제공

![디렉터는 작동하는 제품을 얻기 위하여 어떤 건축 단계들을 실행해야 하는지 알고 있음](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled%205.png)

디렉터는 작동하는 제품을 얻기 위하여 어떤 건축 단계들을 실행해야 하는지 알고 있음

- 프로그램에 디렉터 클래스를 포함하는 것은 필수사항은 아님
- 언제든지 클라이언트 코드에서 생성단계들을 직접 특정 순서로 호출할 수 있음

## 구조

![Untitled](%E1%84%87%E1%85%B5%E1%86%AF%E1%84%83%E1%85%A5%20Builder%20a324a8e155c74c1a967ef5771da9978e/Untitled%206.png)

1. 빌더 인터페이스는 모든 유형의 빌더들에 공통적인 제품 생성 단계들을 선언함
2. 구상 빌더들은 생성 단계들의 다양한 구현을 제공함
   - 구상 빌더들은 공통 인터페이스를 따르지 않는 제품들을 생상할 수 있음
3. 제품들은 그 결과로 나온 객체들임
   - 다른 빌더에 의해 생성된 제품들은 같은 클래스 계층구조 또는 인터페이스에 속할 필요가 없음
4. 디렉터 클래스는 생성 단계들을 호출하는 순서를 정의하므로 제품들의 특정 설정을 만들고 재사용할 수 있음
5. 클라이언트는 빌더 객체들 중 하나를 디렉터와 연결해야 함
   - 일반적으로 위 연결은 디렉터 생성자의 매개변수들을 통해 한 번만 수행되며, 그 후 디렉터는 모든 추가 생성에 해당 빌더 객체들을 사용함
   - 그러나 클라이언트가 빌더 객체를 디렉터의 프로덕션 메서드에 전달할 때를 위한 대안적 접근 방식이 있음
   - 이 경우 디렉터와 함께 무언가를 만들 때마다 다른 빌더를 사용할 수 있음
