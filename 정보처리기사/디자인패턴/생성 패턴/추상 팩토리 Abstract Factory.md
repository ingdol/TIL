# 추상 팩토리 Abstract Factory

[추상 팩토리 패턴](https://refactoring.guru/ko/design-patterns/abstract-factory)

# 의도

- 추상 팩토리 : 관련 객체들의 구상 클래스들을 지정하지 않고도 관련 객체들의 모음을 생성할 수 있도록 하는 생성패턴

![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled.png)

# 문제

- 예를 들어) 가구 판매장을 위한 프로그램을 만들고 있다고 가정
  - 다음을 나타내는 클래스들로 구성
    1. 관련 제품들로 형성된 제품군
       1. `Chair` (의자) + `Sofa` (소파) + `CoffeeTable` (커피 테이블)
    2. 해당 제품군의 여러 가지 변형
       1. `Modern` (현대식)
       2. `Victorian` (빅토리안)
       3. `ArtDeco` (아르데코 양식)

![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled%201.png)

- 새로운 개별 가구 객체를 생성했을 때, 이 객체들이 기존의 같은 제품군 내에 있는 다른 가구 객체들과 일치하는 변형(스타일)을 가지도록 할 방법이 필요함
  - 우리의 고객이 원하는 스타일로 받지 못할 경우 크게 실망하기 때문
  ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled%202.png)
- 가구 공급업체들은 카탈로그를 매우 자주 변경하기 때문
  - 그들은 새로운 제품 또는 제품군을 추가할 때마다 기존 코드를 변경해야 하는 번거로움을 피하고 싶음

# 해결책

1. 첫 번째 방안
   - 각 제품군에 해당하는 개별적인 인터페이스를 명시적으로 선언
     - 예) 의자, 소파, 커피 테이블
   - 제품의 모든 변형이 위 인터페이스를 따르도록 함
     - 예) 모든 의자의 변형들은 `Chair` (의자) 인터페이스를 구현
     ![같은 객체의 모든 변형은 단일 클래스 계층구조로 옮겨져야 함](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled%203.png)
     같은 객체의 모든 변형은 단일 클래스 계층구조로 옮겨져야 함
2. 추상 팩토리 패턴을 선언
   - 추상 팩토리 패턴 : 제품군 내의 모든 개별 제품들의 생성 메서드들이 목록화되어 있는 인터페이스
     - 예) `createChair` (의자 생성), `createSofa` (소파 생성), `createCoffeeTable` (커피 테이블 생성) 등
     ![각 구상 팩토리는 특정 제품의 변형에 해당됨](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled%204.png)
     각 구상 팩토리는 특정 제품의 변형에 해당됨
3. 제품 변형
   - 제품군의 각 변형에 대해 추상 팩토리 인터페이스를 기반으로 별도의 팩토리 클래스를 생성함
   - 팩토리는 특정 종류의 제품을 반환하는 클래스
     - 예) `ModernFurnitureFactory` (현대식 가구 팩토리)에서는 다음 객체들만 생성 가능
     - `ModernChair` (현대식 의자), `ModernSofa` (현대식 소파), `MordernCoffeeTable` (현대식 커피 테이블)
   - 클라이언트 코드는 자신에 해당하는 추상 인터페이스를 통해 팩토리들과 제품들 모두와 함께 작동
     - 클라이언트 코드에 넘기는 팩토리의 종류와 제품 변형들을 클라이언트 코드를 손상하지 않으며 자유자재로 변경 가능
     ![클라이언트들은 함께 작업하는 팩토리의 구상 클래스에 대해 신경을 쓰지 않아도 됨](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled%205.png)
     클라이언트들은 함께 작업하는 팩토리의 구상 클래스에 대해 신경을 쓰지 않아도 됨
4. 클라이언트가 팩토리에 의자를 주문했다고 가정

   - 클라이언트는 팩토리의 클래스들을 알 필요가 없으며, 팩토리가 어떤 변형의 의자를 생성할지 전혀 신경을 쓰지 않음
   - 클라이언트는 추상 `Chair` (의자) 인터페이스를 사용하여, 현대식 의자이든 빅토리아식 의자이든 종류에 상관없이 모든 의자를 항상 동일한 방식으로 주문
   - 클라이언트가 의자에 대해 `sitOn` (앉을 수 있다)라는 메서드를 구현함
   - 그러나 생성된 의자의 변형은 항상 같은 팩토리 객체에서 생성된 소파 또는 커피 테이블의 변형과 같을 것임

5. 명학히 짚고 넘어갈 점

- 클라이언트가 추상 인터페이스에만 노출된다면 실제 팩토리 객체를 생성하는 것은 무엇일까?
  - 일반적으로 프로그램은 초기화 단계에서 구상 팩토리 객체를 생성함
  - 그 직전에 프로그램은 환경 또는 구성 설정에 따라 팩토리 유형을 선택해야 함

# 구조

![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%20Abstract%20Factory%206f1b147884124e83ae29fcf529e34605/Untitled%206.png)

1. 추상 제품들은 제품군을 구성하는 개별 연관 제품들의 집합에 대한 인터페이스들을 선언함
2. 구상 제품들은 변형들로 그룹화된 추상 제품들의 다양한 구현들임
   - 각 추상 제품(의자/소파)는 주어진 모든 변형(빅토리안/현대식)에 구현되어야 함
3. 추상 팩토리 인터페이스는 각각의 추상 제품들을 생성하기 위한 여러 메서드들의 집합을 선언함
4. 구상 팩토리들은 추상 팩토리의 생성 메서드들을 구현함
   - 각 구상 팩토리는 제품들의 특정 변형들에 해당하며 해당 특정 변형들만 생성함
5. 구상 팩토리들은 구상 제품들을 인스턴스화하나, 그 제품들의 생성 메서드들의 시그니처들은 그에 해당하는 추상 제품들을 반환해야 함
   - 그래야 팩토리를 사용하는 클라이언트 코드가 팩토리에서 받은 제품의 특정 변형과 결합되지 않음
   - 클라이언트는 추상 인터페이스를 통해 팩토리/제품 변형의 객체들과 소통하는 한 그 어떤 구상 팩토리/제품 변형과 작업할 수 있음
