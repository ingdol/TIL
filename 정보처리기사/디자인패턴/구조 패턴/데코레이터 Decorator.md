# 데코레이터 Decorator

[데코레이터 패턴](https://refactoring.guru/ko/design-patterns/decorator)

# 의도

- 데토레이터는 객체들을 새로운 행동들을 포함한 특수 래퍼 객체들 내에 넣어서 위 행동들을 해당 객체들에 연결시키는 구조적 디자인 패턴

![Untitled](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled.png)

# 문제

- 알림 라이브러리를 만들고 있다고 가정
    - 이 라이브러리의 목적은 다른 프로그램들이 사용자에게 중요한 이벤트들에 대해 알릴 수 있도록 하는 것
- 라이브러리의 초기 버전은 `Notifier` (알림자) 클래스를 기반으로 했음
    - 이 클래스에는 몇 개의 필드들, 하나의 생성자, 단일 `send` (전송) 메서드만 있음
    - 이 메서드는 클라이언트로부터 메시지 인수를 받은 후 그 메시지를 알림자의 생성자를 통해 알림자에게 전달된 이메일 목록으로 보낼 수 있음
- 클라이언트 역할을 한 타사 앱은 알림자 객체를 한번 생성하고 설정한 후 중요한 일이 발생할 때마다 사용하게 되어 있음

![프로그램은 알림자 클래스를 사용하여 미리 정의된 이메일들의 집합에 중요한 이벤트에 대한 알림을 보낼 수 있음](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%201.png)

프로그램은 알림자 클래스를 사용하여 미리 정의된 이메일들의 집합에 중요한 이벤트에 대한 알림을 보낼 수 있음

- 우리는 어느 시점에서 라이브러리 사용자들이 이메일 알림 이상을 기대한다는 것을 알게 됨
    - 그 중 많은 사용자는 중요한 사안에 대해 SMS 문제, 페이스북 알림, 슬랙 알림을 받고 싶어함
    
    ![각 알림 유형은 알림자의 자식 클랙스로 구현됨](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%202.png)
    
    각 알림 유형은 알림자의 자식 클랙스로 구현됨
    
- `Notifier` (알림자) 클래스를 확장하고 추가 알림 메서드들을 새 자식 클래스들에 넣어 이제 클라이언트가 사용자가 원하는 알림 클래스를 인스턴스화하고 모든 추가 알림에 사용하도록 앱을 설계
- 여러 유형의 알림을 한 번에 사용할 수는 없는지에 대한 문제가 생김
    - 이를 해결하기 위해 하나의 클래스 내에서 여러 알림 메서드를 합성한 특수 자식 클래스들을 만들었으나, 이 접근 방식은 라이브러리 코드 뿐만 아니라 클라이언트 코드도 엄청나게 부풀릴 것이라는 사실이 금세 명백해짐

![자식 클래스들의 합성으로 인한 클래스 수의 폭발](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%203.png)

자식 클래스들의 합성으로 인한 클래스 수의 폭발

- 알림 클래스들의 수가 지나치게 많아지지 않도록 알림 클래스들이 구성하는 다른 방법을 찾아야 함

# 해결책

- 객체의 동작을 변경해야 할 때 가장 먼저 고려되는 방법 = 클래스의 확장
    - 그러나 상속에는 심각하게 주의해야 할 몇 가지 사항들이 있음

1. 상속은 정적이다.
    - 런타임(실행시간) 때 기존 객체의 행동을 변경할 수 없음
    - 전체 객체를 다른 자식 클래스에서 생성된 다른 객체로만 바꿀 수 있음
2. 자식 클래스는 하나의 부모 클래스만 가질 수 있음
    - 대부분 언어에서의 상속은 클래스가 동시에 여러 클래스의 행동을 상속하도록 허용하지 않음

- 이러한 주의 사항을 극복하는 방법의 하나 : 상속 대신 집합 관계 또는 합성을 사용하는 것
    - 이 두 대안은 모두 같은 방식으로 작동
    - 집합 관계 : 한 객체가 다른 객체에 대한 참조를 갖고 일부 작업을 위임함
    - 반면, 상속을 사용하면 객체 자체가 부모 클래스에서 행동을 상속한 후 해당 작업을 수행할 수 있음
- 이 새로운 접근 방식을 사용하면 연결된 ‘도우미’ 객체를 다른 객체로 쉽게 대체하여 런타임 때 컨테이너의 행동을 변경할 수 있음
    - 객체는 여러 클래스의 행동을 사용할 수 있고
    - 여러 객체에 대한 참조들이 있으며
    - 이 객체들에 모든 종류의 작업을 위임함
- 집합 관계/합성은 데코레이터를 포함한 많은 디자인 패턴의 핵심 원칙임

![상속과 집합 관계의 차이점](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%204.png)

상속과 집합 관계의 차이점

- ‘래퍼’는 패턴의 주요 아이디어를 명확하게 표현하는 데코레이터 패턴의 별명
    - 일부 대상 객체와 연결할 수 있는 객체
    - 대상 객체와 같은 메서드들의 집합이 포함되어 있음
    - 자신이 받는 모든 요청을 대상 객체에 위임함
    - 그러나, 이 요청을 대상에 전달하기 전이나 후에 무언가를 수행하여 결과를 변경할 수 있음
- 간단한 래퍼는 언제 진정한 데코레이터가 될 수 있을까?
    - 래퍼는 래핑된 객체와 같은 인터페이스를 구현함
    - 그러므로 클라이언트의 관점에서 이러한 객체들은 같음
    - 이제 래퍼의 참조 필드가 해당 인터페이스를 따르는 모든 객체를 받도록 함
    - 이렇게 하면 여러 래퍼로 객체를 포장해서 모든 래퍼들의 합성된 행동들을 객체에 추가할 수 있음
- 알림 라이브러리에서 기초 `Notifier` 클래스 내에 있는 간단한 이메일 알림 행동은 그대로 두고 다른 모든 알림 메서드들을 데코레이터로 바꾸어 봄

![다양한 알림 메서드들이 데코레이터가 됨](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%205.png)

다양한 알림 메서드들이 데코레이터가 됨

- 클라이언트 코드는 기초 알림자 객체를 클라이언트의 요구사항들과 일치하는 데코레이터들의 집합으로 래핑해야 함
    - 위 결과 객체들은 스택으로 구성됨

![앱들은 알림 데코레이터들의 복잡한 스택들을 설정할 수 있음](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%206.png)

앱들은 알림 데코레이터들의 복잡한 스택들을 설정할 수 있음

- 스택의 마지막 데코레이터는 실제로 클라이언트와 작업하는 객체
    - 모든 데코레이터들은 기초 알림자와 같은 인터페이스를 구현하므로
    - 나머지 클라이언트 코드는 자신이 ‘순수한’ 알림자 객체와 작동하든 데코레이터로 장식된 알림자 객체와 함께 작동하든 상관하지 않음
- 메시지 형식 지정 또는 수신자 리스트 작성과 같은 다른 행동들에도 같은 접근 방식을 적용할 수 있음
    - 클라이언트는 객체가 다른 객체들과 같은 인터페이스를 따르는 한 객체를 모든 사용자 지정 데코레이터로 장식할 수 있음

# 실제상황 적용

![여러 벌의 옷을 입으면 복합 효과를 얻을 수 있음](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%207.png)

여러 벌의 옷을 입으면 복합 효과를 얻을 수 있음

- 옷을 입는 것 = 데코레이터 패턴을 사용하는 예
    - 이 모든 옷은 기초 행동을 ‘확장’하지만
    - 우리의 일부가 아니기에 필요하지 않을 때마다 옷을 쉽게 벗을 수 있음

# 구조

![Untitled](%E1%84%83%E1%85%A6%E1%84%8F%E1%85%A9%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20Decorator%2009f04950a62b400b8cf3727bf29003b3/Untitled%208.png)

1. 컴포넌트
    - 래퍼들과 래핑된 객체들 모두에 대한 공통 인터페이스를 선언함
2. 구상 컴포넌트
    - 래핑되는 객체들의 클래스
    - 기본 행동들을 정의하고 해당 기본 행동들은 데코레이터들이 변경할 수 있음
3. 기초 데코레이터
    - 기초 데코레이터 클래스에는 래핑된 객체를 참조하기 위한 필드
    - 필드의 유형은 구상 컴포넌트들과 구상 데코레이터들을 모두 포함할 수 있도록 컴포넌트 인터페이스로 선언되어야 함
    - 그 후 기초 데코레이터는 모든 작업들을 래핑된 객체에 위임함
4. 구상 데코레이터
    - 컴포넌트들에 동적으로 추가될 수 있는 추가 행동들을 정의함
    - 기초 데코레이터의 메서드를 오버라이드(재정의)
    - 해당 행동을 부모 메서드를 호출하기 전이나 후에 실행함
5. 클라이언트
    - 아래 언급한 데코레이터들이 컴포넌트 인터페이스를 통해 모든 객체와 작동하는 한 컴포넌트들을 여러 계층의 데코레이터들로 래핑할 수 있음