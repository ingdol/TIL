# 어댑터 Adapter

[어댑터 패턴](https://refactoring.guru/ko/design-patterns/adapter)

# 의도

- 어댑터 :  호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴

![Untitled](%E1%84%8B%E1%85%A5%E1%84%83%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%20Adapter%2054c00a7aed134b8780561f06980d761f/Untitled.png)

# 문제

- 주식 시장 모니터링 앱을 만든다고 가정
    - 이 앱은 여러 소스에서 주식 데이터를 XML 형식으로 다운로드한 후 사용자에게 보기 좋은 차트들과 다이어그램들로 표시한다고 가정
    - 이를 개선하려고 하자, 이 분석 라이브러리는 JSON 형식의 데이터로만 작동한다는 것을 알게 됨

![위 분석 라이브러리는 앱과 호환되지 않는 형식의 데이터를 기다리고 있음](%E1%84%8B%E1%85%A5%E1%84%83%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%20Adapter%2054c00a7aed134b8780561f06980d761f/Untitled%201.png)

위 분석 라이브러리는 앱과 호환되지 않는 형식의 데이터를 기다리고 있음

- 이 라이브러리를 XML과 작동하도록 변경할 수 있으나, 라이브러리에 의존하는 일부 기존 코드가 손상될 수 있음
    - 처음부터 타사의 라이브러리 소스 코드에 접근하는 것이 불가능하여 위의 해결 방식을 사용하지 못할 수 있음

# 해결책

- 어댑터 : 한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환하는 특별한 객체
    - 변환의 복잡성을 숨기기 위하여 객체 중 하나의 래핑(포장)함
    - 래핑된 객체는 어댑터를 인식하지도 못함
    - 예를 들어) 미터 및 킬로미터 단위로 작동하는 객체의 모든 데이터를 피트 및 마일과 같은 영국식 단위로 변환하는 어댑터로 래핑할 수 있음
- 어댑터는 데이터를 다양한 형식으로 변환할 수 있을 뿐만 아니라 다른 인터페이스를 가진 객체들이 협업하는데에도 도움을 줌
- 작동 과정
    1. 어댑터는 기존에 있는 객체 중 하나와 호환되는 인터페이스를 받음
    2. 이 인터페이스를 사용하면 기존 객체는 어댑터의 메서드들을 안전하게 호출할 수 있음
    3. 호출을 수신하면 어댑터는 이 요청을 두 번째 객체에 해당 객체가 예상하는 형식과 순서대로 전달
- 양방향으로 호출을 변환할 수 있는 양방향 어댑터를 만드는 것도 가능

![Untitled](%E1%84%8B%E1%85%A5%E1%84%83%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%20Adapter%2054c00a7aed134b8780561f06980d761f/Untitled%202.png)

- 형식이 호환되지 않는 문제를 해결하기 위해 앱의 코드와 직접 작동하는 분석 라이브러리의 모든 클래스에 대한 XML → JSON 변환 어댑터를 만듦
    - 이러한 어댑터들을 통해서만 해당 라이브러리와 통신하도록 코드를 조정
    - 어댑터는 호출을 받으면 들어오는 XML 데이터를 JSON 구조로 변환한 후 해당 호출을 래핑된 분석 객체의 적절한 메서드들에 전달함

# 실제상황 적용

![Untitled](%E1%84%8B%E1%85%A5%E1%84%83%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%20Adapter%2054c00a7aed134b8780561f06980d761f/Untitled%203.png)

- 각 국가에 맞는 전원 플로그 어댑터 사용

# 구조

### 객체 어댑터

- 이 구현은 객체 합성 원칙을 사용
    - 어댑터는 한 객체의 인터페이스를 구현하고 다른 객체는 래핑
    
    ![Untitled](%E1%84%8B%E1%85%A5%E1%84%83%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%20Adapter%2054c00a7aed134b8780561f06980d761f/Untitled%204.png)
    
1. 클라이언트
    - 프로그램의 기존 비즈니스 로직을 포함하는 클래스
2. 클라이언트 인터페이스
    - 다른 클래스들이 클라이언트 코드와 공동 작업할 수 있도록 따라야 하는 프로토콜
3. 서비스
    - 일반적으로 타사 또는 레거시의 유용한 클래스
    - 클라이언트는 서비스 클래스를 직접 사용할 수 없음
        - 왜냐하면 서비스 클래스는 호환되지 않는 인터페이스를 가지고 있기 때문
4. 어댑터
    - 클라이언트와 서비스 양쪽에서 작동할 수 있는 클래스
    - 서비스 객체를 래핑하는 동안 클라이언트 인터페이스를 구현함
    - 어댑터는 어댑터 인터페이스를 통해 클라이언트로부터 호출들을 수신한 후 이 호출을 래핑된 서비스 객체가 이해할 수 있는 형식의 호출들로 변환
5. 클라이언트 코드
    - 클라이언트 인터페이스를 통해 어댑터와 작동하게 되어 구상 어댑터 클래스와 결합하지 않음
        - 덕분에 기존 클라이언트 코드를 손상하지 않고 새로운 유형의 어댑터들을 프로그램에 도입 가능
    - 서비스 클래스의 인터페이스가 변경되거나 교체될 때 유용함

### 클래스 어댑터

- 이 구현은 상속을 사용하며, 어댑터는 동시에 두 객체의 인터페이스를 상속함
    - 이 방식은 C++와 같이 다중 상속을 지원하는 프로그래밍 언어에서만 구현 가능

![Untitled](%E1%84%8B%E1%85%A5%E1%84%83%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%20Adapter%2054c00a7aed134b8780561f06980d761f/Untitled%205.png)

1. 클래스 어댑터
    - 객체를 래핑할 필요가 없음
        - 그 이유는 클라이언트와 서비스 양쪽에서 행동들을 상속받기 때문
        - 위의 어댑테이션(적용)은 오버라이딩된 메서드 내에서 발생
        - 위 어댑터는 기존 ㅋ늘라이언트 클래스 대신 사용할 수 있음