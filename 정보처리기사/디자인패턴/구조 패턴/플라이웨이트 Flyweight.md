# 플라이웨이트 Flyweight

[플라이웨이트 패턴](https://refactoring.guru/ko/design-patterns/flyweight)

## 의도

- 플라이웨이트는 각 객체에 모든 데이터를 유지하는 대신 여러 객체들 간에 상태의 공통 부분들을 공유하여 사용할 수 있는 RAM에 더 많은 객체들을 포함할 수 있도록 하는 구조 디자인 패턴

![Untitled](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20Flyweight%20d257162003fa45a4acc9de8400088948/Untitled.png)

## 문제

- 플레이어들이 지도를 돌아다니며 서로에게 총을 쏘는 간단한 비디어 게임을 만든다고 가정
  - 이 안에서 방대한 양의 총알들, 미사이들 및 파편들을 선사하기 위해 사실적인 입자 시스템을 구현해야 함
  - 그러나 용량이 충분하지 않아 저용량 RAM에서는 게임이 충돌할 수 있음

![Untitled](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20Flyweight%20d257162003fa45a4acc9de8400088948/Untitled%201.png)

## 해결책

- `Particle` (입자) 클래스에는 `color` 및 `sprite` 필드들이 다른 필드들보다 훨씬 더 많은 메모리를 사용함
  - 이 두 필드가 모든 입자에 걸쳐 거의 같은 데이터를 저장한다는 것임
    ![Untitled](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20Flyweight%20d257162003fa45a4acc9de8400088948/Untitled%202.png)
- 좌표, 이동 벡터 및 속도와 같은 입자 상태의 다른 부분들은 각 입자마다 고유하며, 이러한 필드들의 값은 시간이 지남에 따라 변경
  - 이 데이터는 입자의 계속 변화하는 콘텍스트를 나타내지만, 색상과 스프라이트는 각 입자마다 일정하게 유지
- 객체의 이러한 상수 데이터를 일반적으로 고유한 상태라고 함
  - 이 데이터는 객체 안에서 존재함
  - 다른 객체들은 이 데이터를 읽을 수만 있고 변경할 수 는 없음
  - 종종 다른 객체들에 의해 ‘외부에서’ 변경되는 객체의 나머지 상태를 공유한 상태라고 함
- 플라이웨이트 패턴은 객체 내부에 공유한 상태의 저장을 중단하고, 대신 이 상태를 이 상태에 의존하는 특정 메서드들에 전달할 것을 제안함
  - 고유한 상태만 객체 내에 유지되므로 해당 고유한 상태는 콘텍스트가 다른 곳에서 재사용할 수 있음
  - 이러한 객체들은 공유한 상태보다 변형이 훨씬 적은 고유한 상태에서만 달라지므로 훨씬 더 적은 수의 객체만 있으면 됨

![Untitled](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20Flyweight%20d257162003fa45a4acc9de8400088948/Untitled%203.png)

- 입자 클래스에서 공유한 상태를 추출했다고 가정
  - 총알, 미사일, 파편의 세 가지 다른 객체만으로도 게임의 모든 입자를 충분히 나타낼 수 있음
  - 고유한 상태만 저장하는 객체를 플라이웨이트라고 함

### 공유한 상태 스토리지

- 공유한 상태는 패턴을 적용하기 전에 객체들을 집합시키는 컨테이너 객체로 이동함
- 게임에서 이것은 `particle` 필드에 모든 입자를 저장하는 주요 `Game` 객체임
  - 공유한 상태를 이 클래스로 이동하려면 개별 입자의 좌표, 벡터 및 속도를 저장하기 위한 여러 배열 필드들을 생성해야 함
  - 입자를 나타내는 특정 플라이웨이트에 대한 참조를 저장하려면 다른 배열이 필요함
  - 이러한 배열들은 같은 인덱스를 사용하여 입자의 모든 데이터에 액세스할 수 있도록 동기화되어야 함

![Untitled](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20Flyweight%20d257162003fa45a4acc9de8400088948/Untitled%204.png)

- 훌륭한 해결책 : 플라이웨이트 객체에 대한 참조와 함께 공유된 상태를 저장할 별도의 콘텍스트 클래스를 만드는 것
  - 이 접근 방식을 사용하려면 컨테이너 클래스에 단일 배열만 있으면 됨
- 이제는 객체들이 이전보다 훨씬 작게 됨
  - 가장 메모리를 많이 사용하는 필드들이 고작 몇 개의 플라이웨이트 객체들로 이동됨
  - 하나의 커다란 플라이웨이트 객체를 몇 천 개의 작은 콘텍스트 객체들이 재사용할 수 있음
  - 더 이상 커다란 플라이웨이트 객체의 데이터를 천 개의 복사본으로 저장할 필요가 없음

### 플라이웨이트와 불변성

- 같은 플라이웨이트 객체가 다른 콘텍스트들에서 사용될 수 있으므로 해당 플라이웨이트 객체의 상태를 수정할 수 없는지 확인해야 함
  - 플라이웨이트는 생성자 매개변수들을 통해 상태를 한 번만 초기화해야 함
  - setter 또는 public 필드들을 다른 객체들에 노출해서는 안됨

### 플라이웨이트 팩토리

- 다양한 플라이웨이트들에 보다 편리하게 액세스하기 위해 기존 플라이웨이트 객체들의 풀을 관리하는 팩토리 메서드를 생성할 수 있음
  - 이 메서드는 클라이언트에서 원하는 플라이웨이트의 고유한 상태를 받아들이고 이 상태와 일치하는 기존 플라이웨이트 객체를 찾고 발견되면 반환함
  - 그렇지 않으면 새 플라이웨이트를 생성하여 풀에 추가함
- 이 메서드를 배치할 수 있는 몇 가지 옵션이 있음
  - 그 중 확실한 장소는 플라이웨이트 컨테이너임
  - 대안으로 새 팩토리 클래스를 생성할 수 있고
  - 팩토리 메서드를 정적으로 만들고 실제 플라이웨이트 클래스에 넣을 수 있음

## 구조

![Untitled](%E1%84%91%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%B5%E1%84%90%E1%85%B3%20Flyweight%20d257162003fa45a4acc9de8400088948/Untitled%205.png)

1. 플라이웨이트 패턴은 단지 최적화에 불과함
   - 이 패턴을 적용하기 전에 프로그램이 동시에 메모리에 유사한 객체들을 대량으로 보유하는 것과 관련된 RAM 소비 문제가 있는지 확인
   - 이 문제가 다른 의미 있는 방법으로 해결될 수 없는지도 확인
2. 플라이웨이트
   - 플라이웨이트 클래스에는 여러 객체들 간에 공유할 수 있는 원래 객체의 상태 부분이 포함됨
   - 같은 플라이웨이트 객체가 다양한 콘텍스트에서 사용될 수 있음
   - 플라이웨이트 내부에 저장된 상태를 고유한(intrinisic) 상태라고 하며, 플라이웨이트의 메서드에 전달된 상태를 공유한(extrinsic) 상태라고 함
3. 콘텍스트
   - 콘텍스트 클래스는 공유한 상태를 포함
   - 이 상태는 모든 원본 객체들에서 고유함
   - 콘텍스트가 플라이웨이트 객체 중 하나와 쌍을 이루면 원래 객체의 전체 상태를 나타냄
4. 일반적으로 원래 객체의 행동은 플라이웨이트 클래스에 남아 있음
   - 플라이웨이트의 메서드의 호출자는 공유한 상태의 적절한 부분들을 메서드의 매개변수들에 전달해야 함
   - 반면에, 행동은 콘텍스트 클래스로 이동할 수 있으며, 이 클래스는 연결된 플라이웨이트를 단순히 데이터 객체로 사용할 것임
5. 클라이언트
   - 플라이웨이트들의 공유된 상태를 저장하거나 계산함
   - 클라이언트의 관점에서 플라이웨이트는 일부 콘텍스트 데이터를 그의 메서드들의 매개변수들에 전달하여 런타임에 설정될 수 있는 템플릿 객체임
6. 플라이웨이트 팩토리
   - 기존 플라이웨이트들의 풀을 관리함
   - 이 팩토리로 인해 클라이언트들은 플라이웨이트들을 직접 만들지 않는 대신 원하는 플라이웨이트의 고유한 상태의 일부를 전달하여 공장을 호출함
   - 팩토리는 이전에 생성된 플라이웨이트들을 살펴보고 검색 기준과 일치하는 기존 플라이웨이트를 반환하거나 기준에 맞는 플라이웨이트가 발견되지 않으면 새로 생성함
