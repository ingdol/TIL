# 브리지 Bridge

[브리지 패턴](https://refactoring.guru/ko/design-patterns/bridge)

# 의도

- 브리지 : 큰 클래스 또는 밀접하게 관련된 클래스들의 집합을 두 개의 개별 계층구조(추상화 및 구현)로 나눈 후 각각 독립적으로 개발할 수 있도록 하는 구조 디자인 패턴

![Untitled](%E1%84%87%E1%85%B3%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20Bridge%20b8c2b9e4c5bd40aabd8f0a3a64ced19b/Untitled.png)

# 문제

### 추상화? 구현?

- `circle` (원) 및 `square` (직사각형)라는 한 쌍의 자식 클래스들이 기하학적 `shape` (모양) 클래스가 있다고 가정
    - 이 클래스 계층 구조를 확장하여 색상을 도입하기 위해 `Red` 및 `Blue` 모양들의 자식 클래스들을 만들 계획
    - 그러나 이미 두 개의 자식 클래스가 있으므로 `BlueCircle` 및 `RedSquare` 와 같은 네 가지의 클래스 조합을 만들어야 함
        
        ![클래스 조합들의 수는 기하급수적으로 증가](%E1%84%87%E1%85%B3%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20Bridge%20b8c2b9e4c5bd40aabd8f0a3a64ced19b/Untitled%201.png)
        
        클래스 조합들의 수는 기하급수적으로 증가
        
- 새로운 모양 유형들과 색상 유형들을 추가할 때마다 계층 구조는 기하급수적으로 성장
- 예를 들어) 삼각형 모양을 추가하려면 각 색상별로 하나씩 두 개의 자식 클래스들을 도입해야 함
    - 그 후 또 새 색상을 추가하려면 각 모양 유형별로 세 개의 자식 클래스가 생성

# 해결책

- 이 문제는 모양과 색상의 두 가지 독립적인 차원에서 모양 클래스들을 확장하려고 하기 때문에 발생 ⇒ 클래스 상속과 관련된 매우 일반적인 문제
- 브리지 패턴은 상속에서 객체 합성으로 전환하여 이 문제를 해결하려고 시도
    - 차원 중 하나의 별도의 클래스 계층구조로 추출하여 원래 클래스들이 한 클래스 내에서 모든 상태와 행동들을 갖는 대신 새 계층구조의 객체를 참조하도록 함
    
    ![클래스 계층구조의 기하급수적인 성장을 방지하기 위하여 그것을 여러 관련 게층구조들로 변환할 수 있음](%E1%84%87%E1%85%B3%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20Bridge%20b8c2b9e4c5bd40aabd8f0a3a64ced19b/Untitled%202.png)
    
    클래스 계층구조의 기하급수적인 성장을 방지하기 위하여 그것을 여러 관련 게층구조들로 변환할 수 있음
    
- 이 접근 방식을 따르면, 색상 관련 코드를 `Red` 및 `Blue` 라는 두 개의 자식 클래스들이 있는 자체 클래스로 추출 가능 → 다음 `Shape` 클래스는 색상 객체들 중 하나를 가리키는 참조 필드를 받음
- 모양은 연결된 색상 객체에 모든 색상 관련 작업을 위임할 수 있음
- 이 참조는 `Shape` 및 `Color` 클래스들 사이의 브리지(다리) 역할을 할 것임
- 이제부터 새 색상들을 추가할 때 모양 계층구조를 변경할 필요가 없으며 그 반대의 경우도 마찬가지

## 추상화와 구현

- GoF의 디자인 패턴은 브리지 패턴 정의의 일부로 추상화 및 구현이라는 용어가 소개됨
- 추상화(인터페이스라고도 함)
    - 일부 개체(entity)에 대한 상위 수준의 제어 레이어
    - 이 레이어는 자체적으로 실제 작업을 수행해서는 안 되며, 작업들을 구현 레이어(플랫폼이라고도 함)에 위임해야 함
    - 참고로 프로그래밍 언어의 인터페이스들이나 추상 클래스와 같은 것이 아님
- 실제 앱을 예로 하면
    - 추상화 : 그래픽 사용자 인터페이스
    - 구현 : 그래픽 사용자 인터페이스 레이어가 사용자와 상호작용하여 그 결과로 호출하는 배경 운영 체제 코드(API)
- 이러한 앱은 두 가지 독립적인 방향으로 확장
    - 다른 여러 가지의 그래픽 사용자 인터페이스를 가짐(예: 일반 고객 또는 관리자용으로 맞춘 인터페이스들)
    - 여러 다른 API들을 지원함(예: 맥, 리눅스 및 윈도우에서 앱을 실행할 수 있는 API들)

### 문제점

- 최악의 경우, 코드 전체에 다양한 API와 다양한 유형의 그래픽 사용자 인터페이스들이 거대한 스파게티 코드 그릇처럼 형성
    
    ![Untitled](%E1%84%87%E1%85%B3%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20Bridge%20b8c2b9e4c5bd40aabd8f0a3a64ced19b/Untitled%203.png)
    
- 특정 인터페이스-플랫폼 조합들과 관련된 코드를 별도의 클래스들로 추출하여 이 복잡함에 질서를 부여할 수 있으나, 이러한 클래스들이 많다는 문제점을 알게 됨
    - 새로운 그래픽 사용자 인터페이스를 추가하거나 다른 API를 지원하려면 점점 더 많은 클래스를 생성해야 하므로 클래스 계층구조는 기하급수적으로 성장

### 해결방안

- 브리지 패턴은 클래스들을 두 개의 계층구조로 분리하라고 제안
    - 추상화 : 앱의 그래픽 사용자 인터페이스 레이어
    - 구현 : 운영체제의 API

![크로스 플랫폼 앱을 구성하는 방법 중 하나](%E1%84%87%E1%85%B3%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20Bridge%20b8c2b9e4c5bd40aabd8f0a3a64ced19b/Untitled%204.png)

크로스 플랫폼 앱을 구성하는 방법 중 하나

- 추상화 객체는 앱의 드러나는 모습을 제어하고 연결된 구현 객체에 실제 작업들을 위임함
    - 서로 다른 구현들은 공통 인터페이스를 따르는 한 상호 호환이 가능하며
    - 이에 따른 같은 그래픽 사용자 인터페이스는 리눅스와 윈도우에 동시에 작동할 수 있음
- 따라서 API 관련 클래스들을 건드리지 않고 그래픽 사용자 인터페이스 클래스들을 변경할 수 있음
    - 다른 운영 체제에 대한 지원을 추가하려면 구현 계층구조 내에 자식 클래스를 생성하기만 하면 됨

# 구조

![Untitled](%E1%84%87%E1%85%B3%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20Bridge%20b8c2b9e4c5bd40aabd8f0a3a64ced19b/Untitled%205.png)

1. 추상화
    - 상위 수준의 제어 논리를 제공
    - 구현 객체에 의존해 실제 하위 수준 작업들을 수행
    
    (프론트 개발)
    
2. 구현
    - 모든 구상 구현들에 공통적인 인터페이스를 선언
    - 추상화는 여기에 선언된 메서드들을 통해서만 구현 객체와 소통할 수 있음
    
    (백엔드의 스웨거)
    
3. 구상 구현들
    - 플랫폼별 맞춤형 코드가 포함
4. 정제된 추상화들
    - 제어 논리의 변형들을 제공
    - 그들의 부모처럼 일반 구현 인터페이스를 통해 다른 구현들과 작업
5. 클라이언트
    - 추상화와 작업하는데만 관심
    - 그러나 추상화 객체를 구현 객체들 중 하나와 연결하는 것도 클라이언트의 역할