# 반복자 Iterator

[반복자 패턴](https://refactoring.guru/ko/design-patterns/iterator)

## 의도

- 반복자는 컬렉션의 요소들의 기본 표현(리스트, 스택, 트리 등)을 노출하지 않고 그들을 하나씩 순회할 수 있도록 하는 행동 디자인 패턴

![Untitled](%E1%84%87%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%20Iterator%20d1aadf386ad9486bb95331099446c240/Untitled.png)

## 문제

- 컬렉션은 프로그래밍에서 가장 많이 사용되는 데이터 유형 중 하나이긴 하지만, 객체 그룹의 단순한 컨테이너에 불과함

![다양한 유형의 컬렉션들](%E1%84%87%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%20Iterator%20d1aadf386ad9486bb95331099446c240/Untitled%201.png)

다양한 유형의 컬렉션들

- 대부분의 컬렉션들은 그들의 요소들을 간단한 리스트들에 저장하나, 그중 일부는 스택, 트리, 그래프 및 기타 복잡한 데이터 구조들을 기반으로 함
- 그러나 컬렉션이 어떻게 구성되어 있는지를 떠나서, 컬렉션은 그 요소들에 접근할 수 있는 어떤 방법을 다른 코드에 제공해야 함
    - 그래야 다른 코드가 이 요소들을 사용할 수 있음
    - 같은 요소에 반복해서 접근하지 않고 컬렉션의 각 요소를 순회하는 방법이 있을 것임
- 리스트로 된 컬렉션이 있다면 아주 쉽게 해결 가능
    - 모든 요소를 루프 처리하면 되기 때문
- 하지만 트리처럼 복잡한 데이터 구조의 요소들은 순차적으로 순회해야 하나?
    - 트리의 깊이를 우선으로 순회하는 것이 나을 수도, 너비를 우선으로 순회하는 것이 나을 수 도 있음
    - 트리 요소들에 대한 임의 접근 등 다른 방식의 순회가 필요함

![같은 컬렉션을 여러 가지 방법들로 순회할 수 있음](%E1%84%87%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%20Iterator%20d1aadf386ad9486bb95331099446c240/Untitled%202.png)

같은 컬렉션을 여러 가지 방법들로 순회할 수 있음

## 해결책

- 반복자 패턴의 주 아이디어는 컬렉션의 순회 동작을 반복자라는 별도의 객체로 추출하는 것

![반복자들은 다양한 순회 알고리즘을 구현함. 여러 반복자 객체들이 동시에 같은 컬렉션을 순회할 수 있음](%E1%84%87%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%20Iterator%20d1aadf386ad9486bb95331099446c240/Untitled%203.png)

반복자들은 다양한 순회 알고리즘을 구현함. 여러 반복자 객체들이 동시에 같은 컬렉션을 순회할 수 있음

- 반복자 객체는 알고리즘 자체를 구현하는 것 외에도 모든 순회 세부 정보들(예 : 현재 위치 및 남은 요소들의 수)을 캡슐화
    - 이 때문에 여러 반복자들이 서로 독립적으로 동시에 같은 컬렉션을 통과할 수 있음
- 일반적으로 반복자들은 컬렉션의 요소들을 가져오기 위한 하나의 주 메서드를 제공함
    - 클라이언트는 이 메서드를 더 이상 아무것도 반환하지 않을 때까지 계속 실행할 수 있음
    - 반복자가 모든 요소를 순회했음을 의미함
- 모든 반복자들은 같은 인터페이스를 구현해야 함
    - 적절한 반복자가 있는 한 클라이언트 코드는 모든 컬렉션 유형들 및 순회 알고리즘들과 호환됨
    - 컬렉션을 순회하는 특별한 방법이 필요하면 컬렉션이나 클라이언트를 변경할 필요 없이 새 반복자 클래스를 만들기만 하면 됨

## 실제상황 적용

![도보로 로마를 탐험하는 다양한 방법들](%E1%84%87%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%20Iterator%20d1aadf386ad9486bb95331099446c240/Untitled%204.png)

도보로 로마를 탐험하는 다양한 방법들

- 여행에서 여러 대안(예: 무작위로 걷기, 스마트폰 네비게이터, 현지 가이드 등) 로마의 많은 관광명소에 대해 반복자들로 작동

## 구조

![Untitled](%E1%84%87%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%20Iterator%20d1aadf386ad9486bb95331099446c240/Untitled%205.png)

1. 반복자
    - 반복자 인터페이스 : 컬렉션의 순회에 필요한 작업들(예 : 다음 요소 가져오기, 현재 위치 가져오기, 반복자 다시 시작 등)을 선언함
2. 구상 반복자
    - 컬렉션 순회를 위한 특정 알고리즘을 구현함
    - 반복자 객체는 순회의 진행 상황을 자체적으로 추적해야 함
    - 여러 반복자들이 같은 컬렉션을 서로 독립적으로 순회할 수 있도록 함
3. 컬렉션
    - 컬렉션 인터페이스 : 컬렉션과 호환되는 반복자들을 가져오기 위한 하나 이상의 메서드들을 선언함
    - 메서드들의 반환 유형은 반복자 인터페이스의 유형으로 선언되어야 함
        - 구상 컬렉션들이 다양한 유형의 반복자들을 반환할 수 있기 때문
4. 구상 컬렉션
    - 클라이언트가 요청할 때마다 특정 구상 반복자 클래스의 새 인스턴스들을 반환함
    - 컬렉션의 나머지 코드는 같은 컬렉션에 있으며
        - 나머지 코드가 어디에 있는지와 같은 세부 사항들은 실제 패턴에 중요하지 않으므로 생략
5. 클라이언트
    - 반복자들과 컬렉션들의 인터페이스를 통해 함께 동작함
    - 클라이언트가 구상 클래스들에 결합하지 않으므로 같은 클라이언트 코드로 다양한 컬렉션들과 반복자들을 사용할 수 있음
    - 일반적으로 클라이언트들은 자체적으로 반복자들을 생성하지 않고 대신 컬렉션들에서 가져옴
        - 그러나 어떤 경우에는(예를 들어 클라이언트가 자체 특수 반복자를 정의할 때) 클라이언트가 반복자를 직접 만들 수 있음