# 커맨드 Command

[커맨드 패턴](https://refactoring.guru/ko/design-patterns/command)

## 의도

- 커맨드는 요청을 요청에 대한 모든 정보가 포함된 독립실행형 객체로 변환하는 행동 디자인 패턴
    - 이 변환은 다양한 요청들이 있는 메서드들을 인수화 할 수 있도록 함
    - 요청의 실행을 지연 또는 대기열에 넣을 수 있도록 함
    - 실행 취소할 수 있는 작업을 지원할 수 있도록 함

## 문제

- 새로운 텍스트 편집기 앱을 개발하고 있다고 가정
    - 다양한 작업을 위한 여러 버튼이 있는 도구 모음(툴바)을 만드는 것
    - 일반 버튼들에 사용할 수 있는 매우 깔끔한 `Button` (버튼) 클래스를 만듦

![앱의 모든 버튼은 같은 클래스에서 파생됨](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled.png)

앱의 모든 버튼은 같은 클래스에서 파생됨

- 버튼은 비슷해보여도 각각 다른 기능들을 수행해야 함
    - 다양한 클릭 핸들러들에 대한 코드는 어디에 둘까?
        - 버튼이 사용되는 각 위치에 수많은 자식 클래스를 만드는 것
        - 자식 클래스들에는 버튼이 클릭 시 실행되어야 하는 코드가 포함

![많은 버튼 자식 클래스들이 존재](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%201.png)

많은 버튼 자식 클래스들이 존재

- 심각한 결함 발생
    - 수많은 자식 클래스들이 존재
    - 기초 `Button` 클래스를 수정할 때마다 이러한 자식 클래스의 코드를 깨뜨릴 위험이 있음
    - 그래픽 사용자 인터페이스 코드는 비즈니스 로직의 불안정한 코드에 어색하게 의존하게 됨

![여러 클래스가 같은 기능을 구현함](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%202.png)

여러 클래스가 같은 기능을 구현함

- 최악의 사항
    - 텍스트 복사/붙여넣기와 같은 여러 위치에서 호출될 코드들이 중복
    - 또한 버튼 뿐만 아니라 무언가를 복사할 콘텍스트 메뉴 또는 `Ctrl+C` 와 같은 기능도 필요

## 해결책

- 올바른 소프트웨어 디자인은 종종 관심사 분리의 원칙을 기반으로 함
    - 일반적인 예) 그래픽 사용자 인터페이스용 레이어와 비즈니스 로직용 레이어의 분리
    - 그래픽 사용자 인터페이스용 레이어 : 모든 입력을 캡처하고 화면에 아름다운 그림을 렌더링하고 사용자와 앱이 수행하는 작업의 결과를 나타내는 역할을 함
    - 그러나 달의 행성 궤도를 계산하거나 연간 보고서를 작성하는 것과 같은 중요한 작업을 수행할 때 그래픽 사용자 인터페이스 레이어는 비즈니스 논리의 배경 레이어들에 작업을 위임함
- 위 내용은 다음과 같이 표현됨
    - 그래픽 사용자 인터페이스 객체가 비즈니스 논리 객체의 메서드를 호출하고 일부 인수를 전달함
    - 위 프로세스는 일반적으로 한 객체가 다른 객체에 요청을 보내는 것이라고 불림

![그래픽 사용자 인터페이스 객체들은 비즈니스 논리 객체들에 직접 접근할 수 있음](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%203.png)

그래픽 사용자 인터페이스 객체들은 비즈니스 논리 객체들에 직접 접근할 수 있음

- 커맨드 패턴은 그래픽 사용자 인터페이스 객체들이 이러한 요청을 직접 보내서는 안된다고 함
    - 대신 모든 요청 세부 정보들(예 : 호출되는 객체, 메서드 이름 및 인수 리스트)을 요청을 작동시키는 단일 메서드를 가진 별도의 커맨드 클래스로 추출하라고 제안
- 커맨드 객체들은 다양한 GUI 객체들과 비즈니스 논리 객체들 간의 링크 역할을 함
    - GUI 객체는 어떤 비즈니스 논리 객체가 요청을 받을지와 이 요청이 어떻게 처리할지에 대하여 알 필요가 없음
    - GUI 객체는 커맨드를 작동시킬 뿐, 작동된 커맨드는 모든 세부 사항을 처리함

![커맨드를 통해 비즈니스 논리 레이어를 접근](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%204.png)

커맨드를 통해 비즈니스 논리 레이어를 접근

- 다음은 커맨드들이 같은 인터페이스를 구현하도록 함
    - 일반적으로 커맨드는 매개변수들을 받지 않은 단일 실행 메서드만을 가짐
    - 이 인터페이스는 다양한 커맨드들을 커맨드들의 구상 클래스들과 결합하지 않고 같은 요청 발신자와 사용할 수 있게 해줌
    - 발신자에 연결된 커맨드 객체들을 전환할 수 있으며, 그렇게 하여 런타임에 발신자의 행동을 변경할 수 있음
- 요청 매개변수들이 빠져있음을 알 수 있음
    - GUI  객체가 비즈니스 레이어 객체에 일부 매개변수들을 제공했을 수 있음
    - 커맨드 실행 메서드에 매개변수들이 없는 어떻게  요청의 세부 정보를 수신자에게 전달할 수 있을까?
        - 커맨드를 이러한 데이터로 미리 설정해놓거나, 이 데이터를 자체적으로 가져올 수 있도록 해야 함

![GUI 객체들은 작업을 커맨드들에 위임함](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%205.png)

GUI 객체들은 작업을 커맨드들에 위임함

- 커맨드 패턴을 적용한 후에는 더 이상 다양한 클릭 행동들을 구현하기 위한 여러 버튼 자식 클래스들이 필요하지 않음
    - 기초 `Button` 클래스에 커맨드 객체에 대한 참조를 저장하는 단일 필드를 넣은 후 이 버튼이 클릭될 때 그 커맨드를 실행하도록 하면 됨
- 이제 가능한 모든 작업에 대해 많은 커맨드 클래스들을 구현하고 이 클래스들을 버튼의 의도된 동작에 따라 특정 버튼들과 연결해야 함
- 메뉴, 단축키 또는 대화 상자와 같은 다른 그래픽 사용자 인터페이스 요소들도 같은 방식으로 구현할 수 있음
    - 사용자가 GUI 요소와 상호 작용할 때 실행되는 커맨드에 연결될 것임
    - 같은 작업과 관련된 요소들은 같은 커맨드들에 연결되어 코드 중복을 방지할 것임
- 결과적으로 커맨드들은 GUI 레이어와 비즈니스 로직 레이어 간의 결합도를 줄이는 편리한 중간 레이어들이 됨

## 실제상황 적용

![레스토랑에서 주문하기](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%206.png)

레스토랑에서 주문하기

- 손님이 레스토랑에서 주문을 하면 웨이터가 종이에 받아 적고 이 종이를 요리사에 전달되어 요리가 나옴
- 종이에 적힌 주문은 커맨드 역할을 함
    - 이 주문은 요리사가 요리할 준비가 될 때까지 대기열에 남아 있음
    - 주문에는 식사를 요리하는 데 필요한 모든 관련 정보가 포함되어 있음
    - 이를 통해 요리사는 손님에게서 주문 세부 사항을 직접 받지 않아도 바로 요리를 시작할 수 있음

## 구조

![Untitled](%E1%84%8F%E1%85%A5%E1%84%86%E1%85%A2%E1%86%AB%E1%84%83%E1%85%B3%20Command%2060d8250b8c9849e198220eb8f9781782/Untitled%207.png)

1. 발송자
    - 발송자 클래스 : 요청들을 시작하는 역할
    - 커맨드 객체에 대한 참조를 저장하기 위한 필드가 있어야 함
    - 발송자는 요청을 수신자에게 직접 보내는 대신 해당 커맨드를 작동시킴
        - 발송자는 커맨드 객체를 생성할 책임이 없으며
        - 일반적으로 생성자를 통해 클라이언트로부터 미리 생성된 커맨드를 받음
2. 커맨드
    - 커맨드 인터페이스는 일반적으로 커맨드를 실행하기 위한 단일 메서드만을 선언함
3. 구상 커맨드
    - 구상 커맨드들은 다양한 유형의 요청을 구현함
    - 자체적으로 작업을 수행해서는 안 됨
    - 대신 비즈니스 논리 객체 중 하나에 호출을 전달해야 함
    - 그러나 코드를 단순화하기 위해 이러한 클래스들은 병합될 수 있음
    - 수신 객체에서 메서드를 실행하는 데 필요한 매개 변수들은 구상 커맨드의 필드들로 선언할 수 있음
        - 생성자를 통해서만 이러한 필드들의 초기화를 허용함으로써 커맨드 객체들을 불변으로 만들 수 있음
4. 수신자
    - 수신자 클래스에는 일부 비즈니스 로직이 포함되어 있음
    - 거의 모든 객체는 수신자 역할을 할 수 있음
    - 대부분의 커맨드들은 요청이 수신자에게 전달되는 방법에 대한 세부 정보만 처리하는 반면 수신자 자체는 실제 작업을 수행함
5. 클라이언트
    - 클라이언트는 구상 커맨드 객체들을 만들고 설정함
    - 수신자 인스턴스를 포함한 모든 요청 매개변수들을 커맨드의 생성자로 전달해야 함
    - 그렇게 만들어진 커맨드는 하나 또는 여러 발송자와 연관될 수 있음