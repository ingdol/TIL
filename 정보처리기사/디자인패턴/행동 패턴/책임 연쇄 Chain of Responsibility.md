# 책임 연쇄 Chain of Responsibility

[책임 연쇄 패턴](https://refactoring.guru/ko/design-patterns/chain-of-responsibility)

## 의도

- 책임 연쇄 패턴은 핸들러의 체인(사슬)을 따라 요청을 전달할 수 있게 해주는 행동 디자인 패턴
    - 각 핸들러는 요청을 받으면 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지를 결정

![Untitled](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled.png)

## 문제

- 온라인 주문 시스템을 개발하고 있다고 가정
    - 인증된 사용자들만 주문을 생성할 수 있도록 시스템에 대한 접근을 제한하려고 함
    - 관리 권한이 있는 사용자들에게는 모든 주문에 대한 전체 접근 권한을 부여하려고 함
- 설계 후 이러한 검사들은 차례대로 수행해야 한다는 사실을 깨달음
    - 사용자들의 자격 증명이 포함된 요청을 받을 때마다 시스템에 대해 사용자 인증을 시도할 수 있음
    - 그러나 이러한 자격 증명이 올바르지 않아서 인증에 실패하면 다른 검사들을 진행할 이유가 없음

![요청은 주문 시스템 자체가 처리할 수 있기 전에 일련의 검사들을 통과해야 함](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled%201.png)

요청은 주문 시스템 자체가 처리할 수 있기 전에 일련의 검사들을 통과해야 함

- 순차 검사들을 몇 가지 더 구현함
    1. 동료 중 한 명이 검증되지 않은 데이터를 주문 시스템에 직접 전달하는 것은 안전하지 않다고 제안 
        - 그래서 요청 내의 데이터를 정제(sanitize)하는 추가 유효성 검사 단계를 추가
    2. 나중에 누군가가 시스템이 무차별 대입 공격에 취약하다는 사실을 발견
        - 이러한 공격을 방어하기 위해 같은 IP 주소에서 오는 반복적으로 실패한 요청을 걸러내는 검사를 즉시 추가
    3. 같은 데이터가 포함된 반복 요청에 대해 캐시된 결과를 반환하여 시스템 속도를 높일 수 있다고 제안
        - 적절한 캐시 응답이 없는 경우에만 요청이 시스템으로 전달되도록 하는 또 다른 검사 추가

![코드가 커질수록 더 복잡](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled%202.png)

코드가 커질수록 더 복잡

- 문제점 발생
    - 새로운 기능을 추가할 때마다 더 복잡해짐
    - 하나의 검사 코드를 바꾸면 다른 검사 코드가 영향을 받음
    - 다른 컴포넌트들을 보호하기 위해 검사를 재사용하려고 할 때 해당 컴포넌트들에 일부 코드를 복제해야 했다는 것
        - 왜냐하면 컴포넌트들이 필요로 한 것은 검사의 일부였지, 모든 검사는 아니었기 때문

## 해결책

- 책임 연쇄 패턴은 특정 행동들을 핸들러라는 독립 실행형 객체들로 변환
    - 위 프로젝트에서 각 검사는 검사를 수행하는 단일 메서드가 있는 자체 클래스로 추출되어야 함
    - 요청은 데이터와 함께 이 메서드에 인수로 전달됨
- 이 패턴은 이러한 핸들러들을 체인으로 연결하도록 제안함
    - 연결된 각 핸들러에는 체인의 다음 핸들러에 대한 참조를 저장하기 위한 필드가 있음
    - 요청을 처리하는 것 외에도 핸들러들은 체인을 따라 요청을 더 멀리 전달함
    - 이 요청은 모든 핸들러가 요청을 처리할 기회를 가질 때까지 체인을 따라 이동함
- 가장 좋은 부분은 핸들러가 요청을 체인 아래로 더 이상 전달하지 않고 추가 처리를 사실상 중지하는 결정을 내릴 수 있다는 것임
- 주문 관리 시스템에서는 하나의 핸들러가 주문 처리를 수행한 다음 요청을 체인 아래로 더 전달할지를 결정함
    - 요청에 올바른 데이터가 포함되어 있다고 가정하면 모든 핸들러들은 인증 확인이든 캐싱이든 그들의 주 행동들을 실행할 수 있음

![핸들러들이 하나씩 줄지어 체인을 형성함](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled%203.png)

핸들러들이 하나씩 줄지어 체인을 형성함

- 핸들러가 요청을 받으면 핸들러는 요청을 처리할 수 있는지를 판단함
    - 처리가 가능한 경우, 핸들러는 이 요청을 더 이상 전달하지 않음
    - 따라서 요청을 처리하는 핸들러는 하나 뿐이거나 아무 핸들러도 요청을 처리하지 않음
    - 이 접근 방식은 그래픽 사용자 인터페이스 내에서 요소들의 스택에서 이벤트들을 처리할 때 매우 일반적임

- 예를 들어, 사용자가 버튼을 클릭하면 결과 이벤트는 그래픽 사용자 인터페이스 요소 체인을 통해 전파됨
    - 이 체인은 버튼으로 시작하여 해당 컨테이너들(예 : 양식 또는 패널)을 따라 이동한 후 메인 애플리케이션 창으로 끝남
    - 이 이벤트는 그를 처리할 수 있는 체인의 첫 번째에 의해 처리됨
    - 이 예가 주목할 만한 이유는 체인이 항상 객체 트리에서 추출될 수 있음을 보여주기 때문
        
        ![체인은 객체 트리의 가지에서부터 형성될 수 있음](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled%204.png)
        
        체인은 객체 트리의 가지에서부터 형성될 수 있음
        
- 모든 핸들러 클래스들이 같은 인터페이스를 구현하는 것은 매우 중요함
    - 각 구상 핸들러는 `execute` 메서드가 있는 다음 핸들러에만 신경을 써야 함
    - 다양한 핸들러들을 사용하여 코드를 핸들러들의 구상 클래스들에 결합하지 않고도 런타임에 체인들을 구성할 수 있음

## 실제상황 적용

![기술 지원 부서로의 전화는 여러 교환원을 거쳐 이루어짐](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled%205.png)

기술 지원 부서로의 전화는 여러 교환원을 거쳐 이루어짐

## 구조

![Untitled](%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B5%E1%86%B7%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AB%20Chain%20of%20Responsibility%203fcbda3373bf43b28b191658670145a4/Untitled%206.png)

1. 핸들러
    - 모든 구상 핸들러에 공통적인 인터페이스를 선언함
    - 여기에는 요청을 처리하기 위한 단일 메서드만 포함되지만
    - 때로는 체인의 다음 핸들러를 세팅하기 위한 다른 메서드가 있을 수도 있음
2. 기초 핸들러
    - 선택적 클래스이며 여기에 모든 핸들러 클래스들에 공통적인 상용구 코드를 넣을 수 있음
    - 일반적으로 이 클래스는 다음 핸들러에 대한 참조를 저장하기 위한 필드를 정의함
    - 클라이언트들은 핸들러를 이전 핸들러의 생성자 세터에 해당 핸들러를 전달하여 체인을 구축할 수 있음
    - 클래스는 디폴트 핸들러 행동을 구현할 수 있음
    - 다음 핸들러의 존재 여부를 확인한 후 다음 핸들러로 실행을 넘길 수 있음
3. 구상 핸들러
    - 요청을 처리하기 위한 실제 코드가 포함되어 있음
    - 각 핸들러는 요청을 받으면 이 요청을 처리할지와 함께 체인을 따라 전달할지를 결정해야 함
    - 핸들러들은 일반적으로 자체 포함형이고 불변하며, 생성자를 통해 필요한 모든 데이터를 한 번만 받음
4. 클라이언트
    - 앱의 논리에 따라 체인들을 한 번만 구성하거나 동적으로 구성할 수 있음
    - 요청은 체인의 모든 핸들러에 보낼 수 있으며, 꼭 첫 번쨰 핸들러일 필요는 없음