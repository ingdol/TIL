# 상태 State

[상태 패턴](https://refactoring.guru/ko/design-patterns/state)

## 의도

- 상태 패턴 : 객체의 내부 상태가 변경될 때 해당 객체가 그의 행동을 변경할 수 있도록 하는 행동 디자인 패턴
    - 객체가 행동을 변경할 때 객체가 클래스를 변경한 것처럼 보일 수 있음

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20State%20d76663f5263249c390ce8307a818a222/Untitled.png)

## 문제

- 상태 패턴은 유한 상태 기계 개념과 밀접하게 관련되어 있음

![유한 상태 기계](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20State%20d76663f5263249c390ce8307a818a222/Untitled%201.png)

유한 상태 기계

- 이 패턴은 모든 주어진 순간에 프로그램이 속해 있을 수 있는 상태들의 수는 유한하다는 것
    - 어떤 고유한 상태 내에서는 프로그램은 다르게 행동
    - 한 상태에서 다른 상태로 즉시 전환될 수 있음
    - 하지만 현재의 상태에 따라 프로그램은 특정 다른 상태로 전환되거나 전환되지 않을 수 있음
    - 이러한 전환 규칙들이 천이(transition)라고도 함
    - 이러한 규칙들 또한 유한하고 미리 결정되어 있음
- 이 접근 방식을 객체들에 적용할 수 있음
    - `Document` 클래스가 있다고 가정
        - 이 문서는 `Draft` (초안), `Moderation` (검토), `Published` (출판됨)의 세 가지 상태 중 하나
        - 문서의 `publish`(출판하기) 메서드는 각 상태에서 약간씩 다르게 작동함
    - `Draft` : 문서를 검토 상태로 이동
    - `Moderation` : 문서를 공개하나, 현재 사용자가 관리자인 경우에만 공개
    - `Published` : 아무 작업도 수행하지 않음

![문서 객체의 가능한 상태들 및 천이(transition)들](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20State%20d76663f5263249c390ce8307a818a222/Untitled%202.png)

문서 객체의 가능한 상태들 및 천이(transition)들

- 상태 머신들은 일반적으로 객체의 상태에 따라 적절한 행동들을 선택하는 많은 조건문(`if` / `switch` )으로 구현됨
    - 이 ‘상태’는 객체의 필드들의 값들의 집합일 뿐임

```java
class Document is
    field state: string
    // …
    method publish() is
        switch (state)
            "draft":
                state = "moderation"
                break
            "moderation":
                if (currentUser.role == "admin")
                    state = "published"
                break
            "published":
                // Do nothing.
                break
    // …
```

- 조건문들에 기반한 상태 머신의 큰 약점 : `Document` 클래스에 상태들과 상태에 의존하는 행동들을 추가할수록 분명해짐
    - 현재 상태에 따라 메서드의 적절한 행동을 선택하는 거대한 조건문들이 대부분의 메서드들에 포함될 것임
    - 이와 같은 코드는 유지 관리하기 매우 어려움
        - 왜냐하면 천이 논리를 변경하려면 모든 메서드들의 상태 조건문들을 변경해야 할 수 있기 때문
- 이 문제는 프로젝트가 개발되면서 더 복잡해지는 경향이 있음
    - 설계 단계에서 가능한 모든 상태와 천이를 예측하는 것은 매우 어려움
    - 따라서, 제한된 조건문들의 집합으로 구축되어 간단명료했던 상태 머신이 시간이 지남에 따라 부풀려서 엉망이 될 수 있음

## 해결책

- 상태 패턴 : 객체의 모든 가능한 상태들에 대해 새 클래스들을 만들고 모든 상태별 행동들을 이러한 클래스들로 추출할 것을 제안함
- 콘텍스트라는 원래 객체는 모든 행동을 자체적으로 구현하는 대신 현재 상태를 나타내는 상태 객체 중 하나에 대한 참조를 저장하는 모든 상태와 관련된 작업을 그 객체에 위임함

![문서는 상태 객체에 작업을 위임함](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20State%20d76663f5263249c390ce8307a818a222/Untitled%203.png)

문서는 상태 객체에 작업을 위임함

- 콘텍스트를 다른 상태로 전환하려면 활성 상태 객체를 새 상태를 나타내는 다른 객체로 바꿔야함
    - 이것은 모든 상태 클래스들이 같은 인터페이스를 따르고
    - 콘텍스트 자체가 이 인터페이스를 통해 객체들과 작동할 때만 가능함
- 이 구조는 전략 패턴과 비슷해 보이지만 중요한 차이점이 있음
    - 상태 패턴의 특정 상태들은 서로를 인식하고 한 상태에서 다른 상태로 천이를 시작할 수 있지만
    - 전략들은 거의 대부분 서로에 대해 알지 못한다는 것임
    

## 구조

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%20State%20d76663f5263249c390ce8307a818a222/Untitled%204.png)

1. 콘텍스트
    - 구상 상태 객체 중 하나에 대한 참조를 저장하고 모든 상태별 작업을 그곳에 위임함
    - 상태 인터페이스를 통해 상태 객체와 통신
    - 새로운 상태 객체를 전달하기 위한 세터를 노출함
2. 상태
    - 상태별 메서드들을 선언함
    - 이러한 메서드들은 모든 구상 상태에서 유효해야 함
    - 왜냐하면 호출될 일 없는 메서드들이 일부 상태 내에 존재하는 것은 원하지 않을 것이기 때문
3. 구상 상태들
    - 상태별 메서드들에 대한 자체적인 구현을 제공함
    - 여러 상태에서 유사한 코드의 중복을 피하기 위해 어떤 공통 행동을 캡슐화하는 중간 추상 클래스들을 제공할 수 있음
    - 상태 객체들은 콘텍스트 객체에 대한 역참조를 저장할 수 있음
        - 이 참조를 통해 상태는 콘텍스트 객체에서 모든 필요한 정보를 가져올 수 있고 상태 천이를 시작할 수 있음
4. 콘텍스트와 구상 상태들 모두 콘텍스트의 다음 상태를 설정할 수 있으며, 콘텍스트에 연결된 상태 객체를 교체하여 실제 상태 천이를 수행할 수 있음