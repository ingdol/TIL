# 중재자 Mediator

[중재자 패턴](https://refactoring.guru/ko/design-patterns/mediator)

## 의도

- 중재자 : 객체 간의 혼란스러운 의존 관계를 줄일 수 있는 행동 디자인 패턴
    - 객체 간의 직접 통신을 제한하고 중재자 객체를 통해서만 협력하도록 함

![Untitled](%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8C%E1%85%A2%E1%84%8C%E1%85%A1%20Mediator%2036b5bb604abd421d88dc0b0db4fd95c2/Untitled.png)

## 문제

- 고객들의 프로필을 만들고 편집하기 위한 대화 상자가 있다고 가정
    - 이 대화 상자는 텍스트 필드, 체크 박스, 버튼 등 다양한 컨트롤들로 구성

![앱이 발전함에 따라 사용자 인터페이스 요소 간의 관계가 혼란스러워짐](%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8C%E1%85%A2%E1%84%8C%E1%85%A1%20Mediator%2036b5bb604abd421d88dc0b0db4fd95c2/Untitled%201.png)

앱이 발전함에 따라 사용자 인터페이스 요소 간의 관계가 혼란스러워짐

- 일부 양식 요소들은 다른 요소들과 상호 작용할 수 있음
    - 예를 들어) ‘저는 개가 있습니다’ 확인란을 선택하면
        - 개의 이름을 입력하기 위한 숨겨진 텍스트 필드가 나타날 수 있고
        - 데이터를 저장하기 전에 모든 필드의 값을 검증해야 하는 제출 버튼이 있을 수 있음

![요소들은 다른 요소들과 많은 관계를 맺을 수 있음. 따라서 일부 요소들을 변경하면 다른 요소들에 영향을 줄 수 있음](%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8C%E1%85%A2%E1%84%8C%E1%85%A1%20Mediator%2036b5bb604abd421d88dc0b0db4fd95c2/Untitled%202.png)

요소들은 다른 요소들과 많은 관계를 맺을 수 있음. 따라서 일부 요소들을 변경하면 다른 요소들에 영향을 줄 수 있음

- 이 논리를 양식 요소들의 코드 내에서 직접 구현하면 요소들의 클래스들을 앱의 다른 양식들에서 재사용하기가 훨씬 더 어려워짐
    - 예를 들어) 다른 양식 내에서는 위에 언급한 개 관련 확인란 클래스를 사용할 수 없음
        - 왜냐하면 기존 클래스가 개의 이름을 입력하기 위한 텍스트 필드와 결합되어 있기 때문
        - 이 경우 프로필 양식 렌더링과 관련된 클래스들을 전부 사용하거나 아예 사용하지 말아야 함

## 해결책

- 중재자 패턴은 서로 독립적으로 작동해야 하는 컴포넌트 간의 모든 직접 통신을 중단
    - 대신 이러한 컴포넌트들은 호출들을 적절한 컴포넌트들로 리다이렉션하는 특수 중재자 객체를 호출 → 간접적으로 협력하게 하라고 제안
    - 컴포넌트들은 수십 개의 동료 컴포넌트들과 결합되는 대신 단일 중재자 클래스에만 의좀
- 위 프로필 편집 양식 예시에서는 대화 상자 클래스 자체가 중재자 역할을 할 수 있음
    - 대화 상자 클래스는 이미 자신의 모든 하위 요소들을 인식하고 있음
    - 새로운 의존관계들을 도입할 필요가 없을 것임

![UI 요소들은 다른 UI 요소들과 중재자 객체를 통해 간접적으로 통신해야 함](%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8C%E1%85%A2%E1%84%8C%E1%85%A1%20Mediator%2036b5bb604abd421d88dc0b0db4fd95c2/Untitled%203.png)

UI 요소들은 다른 UI 요소들과 중재자 객체를 통해 간접적으로 통신해야 함

- 가장 중요한 변경들은 실제 양식 요소들에 적용됨
    - 제출 버튼을 보면 이전에 사용자가 이 버튼을 클릭할 때마다 버튼은 모든 개별 양식 요소들의 값을 검증해야 했음
    - 이제 제출 버튼이 해야 할 유일한 일은 클릭을 대화 상자에 알리는 것 하나
    - 이 알림을 받으면 대화 상자는 스스로 검증을 수행하거나 개별 요소들에게 작업을 전달함
    - 따라서 버튼은 여러 개의 양식 요소들에 연결되는 대신 대화 상자 클래스에만 의존하게 됨
- 모든 유형의 대화 상자에서 공통 인터페이스를 추출하여 의존성을 더욱 느슨하게 만들 수 있음
    - 이 인터페이스는 모든 양식 요소가 해당 요소들에 발생하는 이벤트들을 대화 상자에 알리는 데 사용할 수 있는 알림 메서드를 선언함
    - 제출 버튼은 이제 해당 인터페이스를 구현하는 모든 대화 상자들과 작업할 수 있음
- 중재자 패턴은 단일 중재자 객체 내부의 다양한 객체 간의 복잡한 관계망을 캡슐화할 수 있도록 함
    - 클래스의 의존관계들이 적을수록 해당 클래스를 수정, 확장 또는 재사용하기가 더 쉬워짐

## 실제상황 적용

![항공기 조종사들은 다음에 누가 비행기를 착륙시킬지를 결정할 때 서로 직접 대화하지 않음. 모든 통신은 비행기 관제탑을 통해 이루어짐](%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8C%E1%85%A2%E1%84%8C%E1%85%A1%20Mediator%2036b5bb604abd421d88dc0b0db4fd95c2/Untitled%204.png)

항공기 조종사들은 다음에 누가 비행기를 착륙시킬지를 결정할 때 서로 직접 대화하지 않음. 모든 통신은 비행기 관제탑을 통해 이루어짐

- 공항 관제 구역으로 들어오거나 떠나는 항공기 조종사들은 직접 통신하지 않음
    - 높은 타워에 앉아서 일하는 항공 교통 관제사와 통신함
- 관제탑은 전체 비행을 관할하지 않음
    - 다만 관련되는 비행기의 수가 조종사에게는 너무 많을 수 있기에 공항 터미널 지역에서만 제약들을 강제하기 위해 존재

## 구조

![Untitled](%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8C%E1%85%A2%E1%84%8C%E1%85%A1%20Mediator%2036b5bb604abd421d88dc0b0db4fd95c2/Untitled%205.png)

1. 컴포넌트
    - 어떤 비즈니스 로직을 포함한 다양한 클래스들
    - 각 컴포넌트에는 중재자에 대한 참조가 있는데, 이 중재자는 중재자 인터페이스의 유형으로 선언됨
    - 컴포넌트는 중재자의 실제 클래스를 인식하지 못하므로 컴포넌트를 다른 중재자에 연결하여 다른 프로그램에서 사용할 수 있음
2. 중재자
    - 단일 알림 메서드만을 포함하는 컴포넌트들과의 통신 메서드들을 선언함
    - 컴포넌트들은 자체 객체들을 포함하여 모든 콘텍스트를 이 메서드의 인수로 전달할 수 있지만  이는 수신자 컴포넌트와 발송자 클래스 간의 결합이 발생하지 않는 방식으로만 가능함
3. 구상 중재자들 
    - 다양한 컴포넌트 간의 관계를 캡슐화함
    - 자신이 관리하는 모든 컴포넌트에 대한 참조를 유지하고
    - 그들의 생명 주기를 관리하기도 함
4. 컴포넌트
    - 다른 컴포넌트들을 인식하지 않아야 함
    - 컴포넌트 내에서 또는 컴포넌트에 중요한 일이 발생하면, 컴포넌트는 이를 중재자에게만 알려야 함
    - 중재자는 알림을 받으면 발송자를 쉽게 식별할 수 있음
        - 이는 응답으로 어떤 컴포넌트가 작동되어야 하는지 결정하기에 충분할 수 있음
    - 컴포넌트 관점에서는 모든 것들이 블랙박스처럼 보임
        - 발송자는 누가 요청을 처리할지 모르고
        - 수신자는 누가 처음에 요청을 보냈는지 모름